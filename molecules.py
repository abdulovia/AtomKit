# -*- coding: utf-8 -*-
"""Molecules

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QneERHzNDpC7QFFMDETowaGi3KsKIHZU
"""

import torch
import torch.nn as nn
from torch.nn import Conv2d
import skimage
import skimage.io
from skimage.color import rgb2gray
import matplotlib.pyplot as plt
from skimage.transform import rescale
import torch
import torchvision
import torchvision.transforms as transforms
import numpy as np
import torch.optim as optim
from torchvision import models
from torch.utils.tensorboard import SummaryWriter
from torchvision.models import resnet18
import os
import skimage
import skimage.io
from skimage.color import rgb2gray
import matplotlib.pyplot as plt
from skimage.transform import rescale
from skimage import data
import pandas as pd
import PIL
import tensorflow as tf
from PIL import Image


from tqdm.notebook import trange, tqdm

def scan_model(filename):
    val_transform = transforms.Compose([
        transforms.Resize(224),
        transforms.RandomAffine(180),
        transforms.RandomCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
    ])

    batch_size = 200

    device = 'cpu'
    print('Using {} device'.format(device))

    def eval_metrics(model, loader, criterion):
        with torch.no_grad():
            epoch_val_accuracy=0
            epoch_val_loss =0
            for data, label in loader:
                data = data.to(device)
                label = label.to(device)

                val_output = model(data)
                val_loss = criterion(val_output,label)


                acc = ((val_output.argmax(dim=1) == label).float().mean())
                epoch_val_accuracy += acc/ len(loader)
                epoch_val_loss += val_loss/ len(loader)

    model = torch.load("/Users/ai/Developer/AtomKit/content/model2.pt")

    TEST_DIRECTORY = "/Users/ai/Developer/AtomKit/content/test"

    class Molecules_test(torch.utils.data.Dataset):
        def __init__(self, imgs, transforms = None):

            super().__init__()
            self.imgs = imgs
            self.transforms = transforms

        def __getitem__(self, idx):

            image_name = self.imgs[idx]

            img = Image.open(TEST_DIRECTORY + "/" + image_name)

            label_name = image_name.split('.')[0]

            ### Apply Transforms on image
            img = self.transforms(img)

            return img, label_name


        def __len__(self):
            return len(self.imgs)

    tesimg = os.listdir(TEST_DIRECTORY)
    #tesimg.remove('.ipynb_checkpoints')
    tesset = Molecules_test(tesimg, val_transform)
    tesloader = torch.utils.data.DataLoader(tesset, batch_size=batch_size,
                                            shuffle=False)

    ans = pd.DataFrame(columns = ['img_id', 'class_id'])
    with torch.no_grad():
        for data in tesloader:
            images, labels = data
            images = images.to(device)
            # calculate outputs by running images through the network
            outputs = model(images)
            # the class with the highest energy is what we choose as prediction
            _, predicted = torch.max(outputs.data, 1)
            d = pd.DataFrame(columns = ['img_id', 'class_id'])
            d['img_id'] = labels
            d['class_id'] = [(int)(a) for a in predicted]
            ans = pd.concat([ans, pd.DataFrame(d,columns = ['img_id', 'class_id'])], ignore_index=True)
    print(ans)
    el_id = ans['class_id'][ans[ans['img_id'] == filename].index.tolist()].tolist()
    print(el_id)
    return el_id[0]
    
if __name__ == "__main__":
    scan_model()